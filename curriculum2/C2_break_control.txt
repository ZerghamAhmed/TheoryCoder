You are an AI agent that must come up with a model of the game you are playing. This model you are making of the game
will be a python program that captures the logic and mechanics of the game. You have began this world model, but it get some 
of the state transitions wrong. Below is your current world model, the action space, and 
the state transitions that you got correct and the ones that you got incorrect.
For the state transitions that are wrong, you will also be provided with that the end state should be after the action. 
You will also be given utilities, typically functions or variables you can use in the world model. You are also given predicates, which are functions you can use in the world model. 

In order to craft the world model you explored your environment with an EXPLORATION PLAN, The changes that resulted in the state and your predication error as a result of this exploration plan is shown.

Please fix your world model to make it work for all the cases and make it be able to return the correct state for the transition. 

Try to make your world model as general as possible and account for possible cases that may arise in the future! 

Notes:

Also DO NOT make changes to "won" in the state dictionary since that will happen outside of the world model.

Feel free to also explain your thinking outside of the markup tags, but know that I will only use the code inside the markup tags. 

ACTION SPACE:

['up', 'down', 'left', 'right']

STATE FORMAT: 

\{
    <object 1>: [(x, y)],  # some object class and its location
    <object 2>: [(x, y), ...],  # some other object class and its locations
    ...  # etc.
    'lost': <bool>,  # Whether game has been lost yet
    'won': <bool>,  # Whether game has been won yet
\}

CURRENT WORLD MODEL:

# make sure to include these import statements
from predicates import *
from copy import deepcopy
from games import BabaIsYou
from babareport import BabaReportUpdater
from utils import directions

# make sure to include these import statements
from copy import deepcopy
from games import BabaIsYou
from babareport import BabaReportUpdater
from utils import directions

def transition_model(state, action):
    # Create a copy of the current state
    new_state = deepcopy(state)
    
    # Get the object we control (in this case, "baba_obj")
    controllable_obj = state['controllables'][0]  # assuming we control only one object for now
    position = state[controllable_obj][0]  # [x, y] position of the object
    
    # Get movement delta for the action (left, right, up, down)
    delta = directions[action]
    
    # Calculate the new position
    new_position = [position[0] + delta[0], position[1] + delta[1]]
    
    # Ensure new position doesn't go beyond the border
    if new_position in state['border']:
        return new_state  # no movement if there's a border
    
    # Check for pushable objects in the new position
    for pushable in state['pushables']:
        if new_position in state[pushable]:
            # Determine new position for the pushable object
            pushable_index = state[pushable].index(new_position)
            new_pushable_position = [new_position[0] + delta[0], new_position[1] + delta[1]]
            
            # If new pushable position is not blocked by border or other pushables
            if new_pushable_position not in state['border'] and all(new_pushable_position not in state[other] for other in state['pushables']):
                new_state[pushable][pushable_index] = new_pushable_position
            else:
                return new_state  # movement is blocked if push can't happen
    
    # Update the position of the controllable object in the new state
    new_state[controllable_obj][0] = new_position
    
    # Check if we overlap with a win condition
    if new_position in state['overlappables']:
        new_state['won'] = True
    
    return new_state







ERRORS FROM WORLD MODEL:

EXPLORATION PLAN : "break_rule baba_word is_word you_word"

Initial state: {'border': [[0, 9], [0, 8], [0, 7], [0, 6], [0, 5], [0, 4], [0, 3], [0, 2], [0, 1], [0, 0], [1, 9], [1, 0], [2, 9], [2, 0], [3, 9], [3, 0], [4, 9], [4, 0], [5, 9], [5, 0], [6, 9], [6, 0], [7, 9], [7, 0], [8, 9], [8, 0], [9, 9], [9, 8], [9, 7], [9, 6], [9, 5], [9, 4], [9, 3], [9, 2], [9, 1], [9, 0]], 'is_word': [[2, 5], [5, 7]], 'win_word': [[2, 4]], 'baba_word': [[4, 7]], 'baba_obj': [[5, 4]], 'you_word': [[6, 7]], 'won': False, 'lost': False, 'controllables': ['baba_obj'], 'overlappables': [], 'pushables': ['win_word', 'baba_word', 'is_word', 'you_word'], ‘rule_formed’: [“baba_word is_word you_word”]}

Next state: {'border': [[0, 9], [0, 8], [0, 7], [0, 6], [0, 5], [0, 4], [0, 3], [0, 2], [0, 1], [0, 0], [1, 9], [1, 0], [2, 9], [2, 0], [3, 9], [3, 0], [4, 9], [4, 0], [5, 9], [5, 0], [6, 9], [6, 0], [7, 9], [7, 0], [8, 9], [8, 0], [9, 9], [9, 8], [9, 7], [9, 6], [9, 5], [9, 4], [9, 3], [9, 2], [9, 1], [9, 0]], 'is_word': [[2, 5], [5, 7]], 'win_word': [[2, 4]], 'baba_word': [[4, 8]], 'baba_obj': [[4, 7]], 'you_word': [[6, 7]], 'won': False, 'lost': False, 'controllables': [], 'overlappables': [], 'pushables': ['win_word', 'baba_word', 'is_word', 'you_word'], ‘rule_formed’: []}

Summary of changes:

"lost": False --> True
"controllables": ['baba_obj'] --> []
 “rule_formed”: [“baba_word is_word you_word”]’ --> []



UTILS:

directions = {
        'left': [-1, 0],
        'right': [1, 0],
        'up': [0, 1],
        'down': [0, -1]
    }


PREDICATES:


from itertools import product
from collections import deque

def negate(result):
    """Return the negated result of the given value."""
    return not result

def are_adjacent(coords):
    """Check if the coordinates are adjacent horizontally or vertically."""
    if len(coords) != 3:
        return False

    # print("Coordinate Combos:", coords)

    # Check horizontal adjacency
    if coords[0][1] == coords[1][1] == coords[2][1] and coords[1][0] == coords[0][0] + 1 and coords[2][0] == coords[1][0] + 1:
        # print('horizontal adjacent')
        return True

    # Check vertical adjacency
    if coords[0][0] == coords[1][0] == coords[2][0] and coords[1][1] == coords[0][1] - 1 and coords[2][1] == coords[1][1] - 1:
        # print('vertical adjacent')
        return True

    return False

def rule_formed(state, word1, word2, word3):
    """Check if the given words are adjacent in the state."""
    coords1 = state.get(word1, [])
    coords2 = state.get(word2, [])
    coords3 = state.get(word3, [])

    if not coords1 or not coords2 or not coords3:
        return False

    # Generate all possible triplets of coordinates, ensuring each word is used once
    for triplet in product(coords1, coords2, coords3):
        if are_adjacent(list(triplet)):
            return True

    return False

def overlapping(state, entity1, index1, entity2, index2):
    """
    Check if a specific instance of one entity overlaps (shares the same coordinate) with a specific instance of another entity.

    Args:
    state (dict): The state dictionary containing entity positions.
    entity1 (str): The first entity to check.
    index1 (int): The index of the instance of the first entity.
    entity2 (str): The second entity to check.
    index2 (int): The index of the instance of the second entity.

    Returns:
    bool: True if the specified instances overlap, False otherwise.
    """
    # Get the list of coordinates for both entities
    coords1 = state.get(entity1, [])
    coords2 = state.get(entity2, [])

    # Check if the indices are within the bounds of the coordinate lists
    if index1 < len(coords1) and index2 < len(coords2):
        # Compare the coordinates at the specified indices
        return tuple(coords1[index1]) == tuple(coords2[index2])

    return False


def at(state, entity, loc, index=None):
    """
    Check if the specific instance of an entity is at the given location.
    If index is None, check if any instance of the entity is at the location.

    Args:
    state (dict): The state dictionary containing entity positions.
    entity (str): The entity to check (e.g., "flag_word").
    loc (list): The location to check (e.g., [6, 8]). MUST BE A LIST NOT Tuple.
    index (int, optional): The index of the specific instance to check. Defaults to None.

    Returns:
    bool: True if the entity (or specific instance) is at the location, False otherwise.
    """
    # breakpoint()
    # Get the list of coordinates for the entity
    coords = state.get(entity, [])

    # breakpoint()
    # breakpoint()
    # Check if a specific instance is requested
    if index is not None:
        if 0 <= index < len(coords):
            return loc == coords[index]
        else:
            return False

    # breakpoint()

    # Check if the location is in the list of coordinates for any instance
    return loc in coords


def is_on_border(state, loc):
    """
    Check if a given location is on the border of the map.

    Args:
    state (dict): The state dictionary containing entity positions.
    loc (list): The location to check (e.g., [0, 5]).

    Returns:
    bool: True if the location is on the border, False otherwise.
    """
    return loc in state.get('border', [])

def rule_formable(state, word1, word2, word3):
    """
    Check if the rule composed of word1, word2, word3 can be formed.

    Args:
    state (dict): The current game state.
    word1 (str): The first word in the rule.
    word2 (str): The second word in the rule.
    word3 (str): The third word in the rule.

    Returns:
    bool: True if the rule is formable, False otherwise.
    """
    for word in [word1, word2, word3]:
        if word.endswith('_word') and not pushable_word(state, word):
            return False
    return True


def pushable_word_up(state, word):
    """
    Check if the word can be pushed upwards.
    
    Args:
    state (dict): The current game state.
    word (str): The word entity to check.
    
    Returns:
    bool: True if the word is pushable upwards, False otherwise.
    """
    for (x, y) in state.get(word, []):
        obj_pos = [x, y + 1]      # Position where baba_obj needs to be to push up
        target_pos = [x, y - 1]   # Position where the word will be pushed to
        
        if target_pos not in state.get('empty', []):
            return False
        if obj_pos not in state.get('empty', []):
            return False
    return True

def pushable_word_down(state, word):
    """
    Check if the word can be pushed downwards.
    
    Args:
    state (dict): The current game state.
    word (str): The word entity to check.
    
    Returns:
    bool: True if the word is pushable downwards, False otherwise.
    """
    for (x, y) in state.get(word, []):
        obj_pos = [x, y - 1]      # Position where baba_obj needs to be to push down
        target_pos = [x, y + 1]   # Position where the word will be pushed to
        
        if target_pos not in state.get('empty', []):
            return False
        if obj_pos not in state.get('empty', []):
            return False
    return True

def pushable_word_left(state, word):
    """
    Check if the word can be pushed to the left.
    
    Args:
    state (dict): The current game state.
    word (str): The word entity to check.
    
    Returns:
    bool: True if the word is pushable to the left, False otherwise.
    """
    for (x, y) in state.get(word, []):
        obj_pos = [x + 1, y]      # Position where baba_obj needs to be to push left
        target_pos = [x - 1, y]   # Position where the word will be pushed to
        
        if target_pos not in state.get('empty', []):
            return False
        if obj_pos not in state.get('empty', []):
            return False
    return True

def pushable_word_right(state, word):
    """
    Check if the word can be pushed to the right.
    
    Args:
    state (dict): The current game state.
    word (str): The word entity to check.
    
    Returns:
    bool: True if the word is pushable to the right, False otherwise.
    """
    for (x, y) in state.get(word, []):
        obj_pos = [x - 1, y]      # Position where baba_obj needs to be to push right
        target_pos = [x + 1, y]   # Position where the word will be pushed to
        
        if target_pos not in state.get('empty', []):
            return False
        if obj_pos not in state.get('empty', []):
            return False
    return True


def pushable_word(state, word):
    """
    Check if the word is pushable in any direction.
    
    Args:
    state (dict): The current game state.
    word (str): The word entity to check.
    
    Returns:
    bool: True if the word is pushable in any direction, False otherwise.
    """
    return (
        pushable_word_up(state, word) or
        pushable_word_down(state, word) or
        pushable_word_left(state, word) or
        pushable_word_right(state, word)
    )

from itertools import product


def get_all_word_entities(state):
    """
    Extract all relevant word entities from the current game state.
    
    Args:
        state (dict): The current game state.
    
    Returns:
        list: A list of all word entities (e.g., "baba_word", "is_word", "flag_word").
    """
    word_entities = [key for key in state if key.endswith('_word')]
    return word_entities

def generate_potential_rules(state):
    """
    Generate all potential rules based on the current game state.
    
    Args:
        state (dict): The current game state.
    
    Returns:
        list of tuples: A list of potential rules (word1, word2, word3).
    """
    word_entities = get_all_word_entities(state)
    
    potential_rules = []
    for word1, word3 in product(word_entities, repeat=2):
        if word1 != word3:  # Avoid self-rules like 'baba_word is_word baba_word'
            potential_rules.append((word1, 'is_word', word3))
    
    return potential_rules


def overlapable(state, entity):
    """
    Check if the given entity is overlapable.

    Args:
        state (dict): The current game state.
        entity (str): The entity to check (e.g., "baba_obj", "flag_obj").

    Returns:
        bool: True if the entity ends with '_obj', False otherwise.
    """
    return entity.endswith('_obj')





RESPONSE FORMAT (make sure to include your code in markup tags):

```Python

# make sure to include these import statements
from predicates import *
from copy import deepcopy
from utils import directions

def transition_model(state, action):


        Return State

```


