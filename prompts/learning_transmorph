You are an AI agent that must come up with a model of the game you are playing. This model you are making of the game
will be a python program that captures the logic and mechanics of the game. You have began this world model, but it get some 
of the state transitions wrong. Below is your current world model, the action space, and 
the state transitions that you got correct and the ones that you got incorrect.
For the state transitions that are wrong, you will also be provided with that the end state should be after the action. 
You will also be given utilities, typically functions or variables you can use in the world model.

In order to craft the world model you explored your environment with an EXPLORATION PLAN, where _x denotes the index of the entity. The changes that resulted in the state and your predication error as a result of this exploration plan is shown.

Please fix your world model to make it work for all the cases and make it be able to return the correct state for the transition. 

Try to make your world model as general as possible and account for possible cases that may arise in the future! 

Notes:

Also DO NOT make changes to "won" in the state dictionary since that will happen outside of the world model.

Feel free to also explain your thinking outside of the markup tags, but know that I will only use the code inside the markup tags. 

ACTION SPACE:

['up', 'down', 'left', 'right']

STATE FORMAT: 

\{
    <object 1>: [(x, y)],  # some object class and its location
    <object 2>: [(x, y), ...],  # some other object class and its locations
    ...  # etc.
    'lost': <bool>,  # Whether game has been lost yet
    'won': <bool>,  # Whether game has been won yet
\}

CURRENT WORLD MODEL:

from predicates import *
from copy import deepcopy
from games import BabaIsYou
from babareport import BabaReportUpdater
from utils import directions

# Function to update pushable entity's coordinates
def make_push(state, pushable, old_coords, delta):
    if pushable in state:
        pushable_new_coords = [old_coords[0] + delta[0], old_coords[1] + delta[1]] 
        index = state[pushable].index(list(old_coords))
        state[pushable][index] = list(pushable_new_coords)
        print(f"PUSHED {pushable} from {old_coords} to {pushable_new_coords}")

def simulate_movement(new_coordinates, delta, grid_size=10):
    listofcoords = []
    for i in range(1, grid_size + 1):
        next_coords = [new_coordinates[0] + i * delta[0], new_coordinates[1] + i * delta[1]]
        listofcoords.append(next_coords)
    return listofcoords


def transition_model(state, action):
    
    # Determine controllable entities (objects corresponding to "is you" rule)
    controllables = {
        entity for entity in state
        if rule_formed(state, f'{entity[:-4]}_word', 'is_word', 'you_word')
    }
    print("controllables", controllables)


    # Determine initial pushable entities
    pushables = {
        entity for entity in state
        if (
            (entity.endswith('_obj') and rule_formed(state, f'{entity[:-4]}_word', 'is_word', 'push_word'))
            or entity.endswith('_word')
        )
    }
    print("initial pushables", pushables)

    # Determine obstacles, excluding controllables and pushables
    obstacles = {
        entity for entity in state
        if entity not in pushables and entity not in controllables
        and entity not in ['empty', 'lost', 'won'] 
    }

    # Remove obstacle entities that are part of the win rule
    for entity in state:
        if entity.endswith('_word') and rule_formed(state, f'{entity}', 'is_word', 'win_word'):
            obj_entity = entity.replace('_word', '_obj')
            obstacles.discard(obj_entity)  

    print("filtered obstacles", obstacles)
            
    obstacle_coords = set()
    for obstacle in obstacles:
        for coord in state[obstacle]:
            obstacle_coords.add(tuple(coord))  

    pushables_coords = set()
    for pushable in pushables:
        for coord in state[pushable]:
            pushables_coords.add(tuple(coord))  

    empties_coords = set()
    for coord in state["empty"]:
        empties_coords.add(tuple(coord))  

    # get controllable entity 
    for obj, coords in state.items():
        if obj.endswith('_obj'):
            obj_name = obj[:-4]
            if obj in controllables:

                print(f"Controlling {obj_name}_obj")

                # turns action into coordinate change for state dict
                if action in directions:
                    delta = directions[action]

                    # need to move all controlled entities in a given direction
                    for i, coord in enumerate(coords):
                        print("printing coords", coord)

                        # calculate new coordinates after move
                        new_coords = [coord[0] + delta[0], coord[1] + delta[1]]
 
                        if tuple(new_coords) not in obstacle_coords and tuple(new_coords) not in pushables_coords:

                            # update obj coordinates after move
                            state[obj][i] = new_coords

                            if tuple(new_coords) in empties_coords:
                                state["empty"].remove(new_coords)

                            state["empty"].append(coord)

                         # # will not change coordinate
                        elif tuple(new_coords) in obstacle_coords:
                            return state
                        
                        # # make sure the move is actual valid (not in border, no non-movable obstructions)
                        elif tuple(new_coords) in pushables_coords:
                            stack = []

                            if delta == [1, 0]:  # right
                                rest_grid = 9 - coord[0]
                            elif delta == [-1, 0]:   
                                rest_grid = coord[0]
                            elif delta == [0, 1]: # up
                                rest_grid = 9 - coord[1]
                            elif delta == [0, -1]:
                                rest_grid = coord[1]
                            else:
                                print("ERROR IN DELTA")

                            # see coordinates along direction vector
                            rest_of_coords = simulate_movement(coord, delta, grid_size=rest_grid)
                            available_space = None
                            blocked_space = None

                            for square in rest_of_coords:
                                if tuple(square) in pushables_coords:
                                    stack.append(square)
                                    print(stack)
                                elif tuple(square) in empties_coords:
                                    available_space = True
                                    break
                                elif tuple(square) in obstacle_coords:
                                    blocked_space = True
                                    break
                
                            print(f"Stack after simulation: {stack}")

                            if available_space:
                                print("THERE IS SPACE FOR PUSHING")
                
                                stack.reverse()

                                # entities to be pushed
                                print(stack)
                                for entity_coords in stack:
                                    for pushable in pushables:
                                        if entity_coords in state[pushable]:
                                            
                                            make_push(state, pushable, entity_coords, delta)

                                # controlled object will be moved to spot and push others of Stack to their new coords
                                state[obj][i] = new_coords
                                state["empty"].append(coord)

                                # Update the empty coordinates by removing the first coordinate in the stack
                                first_in_stack = stack[0]
                                if tuple(first_in_stack) in empties_coords:
                                    state["empty"].remove(first_in_stack)
                                    
                                else:
                                    state["empty"].append(first_in_stack)
                                    return state

                            else:
                                return state
                        
    return state




ERRORS FROM WORLD MODEL:

EXPLORATION PLAN : "form_rule rock_word_1 is_word_3 flag_word_2"

Initial state: {'border': [[0, 9], [0, 8], [0, 7], [0, 6], [0, 5], [0, 4], [0, 3], [0, 2], [0, 1], [0, 0], [1, 9], [1, 0], [2, 9], [2, 0], [3, 9], [3, 0], [4, 9], [4, 0], [5, 9], [5, 0], [6, 9], [6, 0], [7, 9], [7, 0], [8, 9], [8, 0], [9, 9], [9, 8], [9, 7], [9, 6], [9, 5], [9, 4], [9, 3], [9, 2], [9, 1], [9, 0]], 'baba_word': [[1, 8]], 'empty': [[1, 7], [1, 6], [1, 5], [1, 4], [1, 3], [1, 2], [1, 1], [2, 7], [2, 6], [2, 5], [2, 4], [2, 3], [2, 2], [2, 1], [3, 7], [3, 6], [3, 5], [3, 4], [3, 3], [3, 2], [3, 1], [4, 8], [4, 7], [4, 6], [4, 5], [4, 4], [4, 3], [4, 2], [5, 8], [5, 7], [5, 6], [5, 5], [5, 4], [5, 3], [5, 2], [6, 7], [6, 6], [6, 5], [6, 4], [6, 3], [6, 2], [6, 1], [7, 7], [7, 6], [7, 4], [7, 3], [7, 2], [8, 7], [8, 6], [8, 5], [8, 4], [8, 3], [8, 2], [4, 1], [5, 1]], 'is_word': [[2, 8], [7, 8], [7, 1]], 'you_word': [[3, 8]], 'baba_obj': [[5, 1]], 'rock_word': [[6, 1]], 'flag_word': [[6, 8], [8, 1]], 'rock_obj': [[7, 5]], 'win_word': [[8, 8]], 'won': False, 'lost': False, 'controllables': ['baba_obj']}
Action: right
Next state: {'border': [[0, 9], [0, 8], [0, 7], [0, 6], [0, 5], [0, 4], [0, 3], [0, 2], [0, 1], [0, 0], [1, 9], [1, 0], [2, 9], [2, 0], [3, 9], [3, 0], [4, 9], [4, 0], [5, 9], [5, 0], [6, 9], [6, 0], [7, 9], [7, 0], [8, 9], [8, 0], [9, 9], [9, 8], [9, 7], [9, 6], [9, 5], [9, 4], [9, 3], [9, 2], [9, 1], [9, 0]], 'baba_word': [[1, 8]], 'empty': [[1, 7], [1, 6], [1, 5], [1, 4], [1, 3], [1, 2], [1, 1], [2, 7], [2, 6], [2, 5], [2, 4], [2, 3], [2, 2], [2, 1], [3, 7], [3, 6], [3, 5], [3, 4], [3, 3], [3, 2], [3, 1], [4, 8], [4, 7], [4, 6], [4, 5], [4, 4], [4, 3], [4, 2], [4, 1], [5, 8], [5, 7], [5, 6], [5, 5], [5, 4], [5, 3], [5, 2], [6, 7], [6, 6], [6, 5], [6, 4], [6, 3], [6, 2], [7, 7], [7, 6], [7, 4], [7, 3], [7, 2], [8, 7], [8, 6], [8, 5], [8, 4], [8, 3], [8, 2]], 'is_word': [[2, 8], [7, 8], [7, 1]], 'you_word': [[3, 8]], 'baba_obj': [[5, 1]], 'flag_word': [[6, 8], [8, 1]], 'rock_word': [[6, 1]], 'flag_obj': [[7, 5]], 'win_word': [[8, 8]], 'won': False, 'lost': False, 'controllables': ['baba_obj']}
Summary of changes:
"empty": Added: []
"empty": Removed: [[6, 1], [5, 1]]
"flag_obj": None --> [[7, 5]]
"rock_obj": [[7, 5]] --> None
Your prediction errors:
"empty": extraneous: [[6, 1], [5, 1]]

"flag_obj": predicted: []
"flag_obj": actual: [[7, 5]]

"rock_obj": predicted: [[7, 5]]
"rock_obj": actual: []


UTILS:

directions = {
        'left': [-1, 0],
        'right': [1, 0],
        'up': [0, 1],
        'down': [0, -1]
    }



RESPONSE FORMAT (make sure to include your code in markup tags):

```Python

# make sure to include these import statements
from predicates import *
from copy import deepcopy
from games import BabaIsYou
from babareport import BabaReportUpdater
from utils import directions

def transition_model(state, action):


        Return State

```

