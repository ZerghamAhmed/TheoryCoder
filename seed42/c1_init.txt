# make sure to include these import statements
from predicates import *
from copy import deepcopy
from games import BabaIsYou
from babareport import BabaReportUpdater
from utils import directions

def transition_model(state, action):
    # Create a deep copy of the state to avoid modifying the original state
    new_state = deepcopy(state)

    # Extract controllable objects and rules from the state
    controllables = new_state['controllables']
    rules = new_state['rules_formed']

    # Define position changes based on the action
    dx, dy = directions[action]

    # Loop through each controllable object
    for obj in controllables:
        # Get the current position of the controllable object
        current_pos = state[obj][0]  # Assuming each controllable object has one position
        new_pos = [current_pos[0] + dx, current_pos[1] + dy]

        # Check if the new position is within the borders
        if new_pos in new_state['border']:
            continue  # Skip if the new position is a border

        # Check for pushable objects and apply rules
        for pushable in new_state['pushables']:
            if new_pos in new_state[pushable]:
                # If the pushable object is at the new position, attempt to push it
                pushable_pos = new_state[pushable][0]
                new_pushable_pos = [pushable_pos[0] + dx, pushable_pos[1] + dy]

                # Check if the new position for the pushable object is valid
                if new_pushable_pos not in new_state['border']:
                    # Move the pushable object
                    new_state[pushable][0] = new_pushable_pos
                else:
                    # If pushable cannot be moved, skip moving the controllable
                    continue

        # Update the position of the controllable object
        new_state[obj][0] = new_pos

    # Check for overlappable objects and apply rules
    for overlappable in new_state['overlappables']:
        if new_pos == new_state[overlappable][0]:
            # If the controllable object overlaps with an overlappable object, check win condition
            if 'flag_word is_word win_word' in rules:
                new_state['won'] = True

    return new_state
