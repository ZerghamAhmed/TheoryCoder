You are an agent playing a 2D grid game, whose raw state is shown below.

Can you give me a minimal PDDL domain and problem file for this setup that will allow the agent to win the game? Think in terms of the most minimal abstract files you can.

Each object in your PDDL problem file is named using ONLY the keys of the raw state dictionary.

There is no reference to coordinates or spatial concepts, like connections etc. For example, you can assume that there are objects and they can be ontop of one another
but do not assume there are physical locations. For example, do NOT propose the predciate "at" or any other position style predicate. In order to express
these types of relationship you can think of the objects being in the same position as overlapping or being on top of one another.

ONLY propose ONE operator

The raw state dictionary keys are considered traversable.
Return your code blocks with
```pddl ```
markup tags so I can easily extract it.

Do NOT use symbols like "-" for the predicate names. For example, the predicate "avatar-at" should NOT be proposed since it has a "-".
Please use all LOWERCASE for the operator names as well!!!!!!!!!!

Few shot example of what a nice abstraction domain and problem file should look like:

BEGIN EXAMPLE

state is 'table': [3, 4], 'mug', [4, 4]

(define (domain toy-domain)
  (:requirements :strips :typing)
  
  (:types
    object
  )

  (:predicates
    (ontop ?x - object ?y - object)
  )

  (:action placeontopof
    :parameters (?obj1 - object ?obj2 - object)
    :precondition (not (ontop ?obj1 ?obj2))
    :effect (ontop ?obj1 ?obj2)
  )
)

(define (problem toy-problem)
  (:domain toy-domain)

  (:objects
    table mug - object
  )

  (:init
    ;; Initially nothing is on top of anything
    (not (ontop mug table))
  )

  (:goal
    (ontop mug table)
  )
)

END EXAMPLE.


Raw state of game (generate the files for this):

{raw_state}

