You are an AI agent that must come up with a transition model of the game you are playing. 

A BFS low-level planner that will use your synthesized transition model to find the low-level actions that will allow you to win levels of the game.

You are also given state transition after executing random actions that will help as well.
Note that if there is no change returned after doing that action, it means that moving was prevented somehow such as by an obstacle. 

The levels you start out with will be simpler but you will be adding on more and more as time progresses. 
So try to make the transition model general and avoid hardcoding anything from the state dictionary keys. Feel free to infer the types of interactions that will occur in later levels. 
Do not feel like you need to build the transition model for just this replay buffer. 
For example, make sure you use each of the categorizations i.e. overlappables, pushables, controllables, etc in your initial world model.
Please make sure to handle pushables in your initial world model too. Pushables cannot overlap with eachother.

BUT A PUSHABLE DOES PUSH ANOTHER PUSHABLE. MAKE NOTE OF THIS if a pushable is pushed and another pushable is occupying that space, that pushable will be pushed
unless there is a border!

Do not assume the win condition is always the same for future levels. Do not change or deal with the win key in the state. 
This will be handled by the game engine, not the transition model.

Do NOT just assume there will be one controllable object, you will need to loop over all the controllables.

Remember there should be logic in your transition model to handle the pushables pushing other pushables!!!!

Also, remember to return the state if you modified it directly or return the new_state if you deepcopied it.

 

CURRENT STATE:

{'border': [[0, 9], [0, 8], [0, 7], [0, 6], [0, 5], [0, 4], [0, 3], [0, 2], [0, 1], [0, 0], [1, 9], [1, 0], [2, 9], [2, 0], [3, 9], [3, 0], [4, 9], [4, 0], [5, 9], [5, 0], [6, 9], [6, 0], [7, 9], [7, 0], [8, 9], [8, 0], [9, 9], [9, 8], [9, 7], [9, 6], [9, 5], [9, 4], [9, 3], [9, 2], [9, 1], [9, 0]], 'baba_word': [[1, 8]], 'is_word': [[2, 8], [7, 8]], 'you_word': [[3, 8]], 'baba_obj': [[3, 4]], 'flag_word': [[6, 8]], 'flag_obj': [[7, 4]], 'win_word': [[8, 8]], 'won': False, 'lost': False, 'controllables': ['baba_obj'], 'overlappables': ['flag_obj'], 'pushables': ['is_word', 'baba_word', 'win_word', 'you_word', 'flag_word'], 'rules_formed': ['baba_word is_word you_word', 'flag_word is_word win_word']}

ACTION SPACE:

['up', 'down', 'left', 'right']

UTILS:

directions = {
    'left': [-1, 0],
    'right': [1, 0],
    'up': [0, 1],
    'down': [0, -1],
}


RESPONSE FORMAT:

- Make sure that you return the correct state for example if you made a deepcopy of the state and modify the deep copy then return the new_state
- If you modify the state directly then return the state instead of new_state

```python

# make sure to include these import statements
from predicates import *
from copy import deepcopy
from utils import directions

def transition_model(state, action):


	Return State

```
