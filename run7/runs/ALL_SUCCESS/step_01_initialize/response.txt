To create a transition model for the game, we need to account for the various object categories and how they interact with each other when an action is performed. We'll handle controllables, pushables, and overlappables, ensuring that the rules for interactions such as pushing are respected. Here's how the transition model can be structured:

```python
from copy import deepcopy
from utils import directions

def transition_model(state, action):
    # Create a deepcopy of the state to avoid modifying the original state directly
    new_state = deepcopy(state)
    
    # Get the action direction vector
    direction = directions[action]
    
    # Iterate over all controllable objects and attempt to move them
    for controllable in state['controllables']:
        # Get the current position of the controllable object
        current_position = state[controllable][0]
        
        # Calculate the new position after the action
        new_position = [current_position[0] + direction[0], current_position[1] + direction[1]]
        
        # Check if the new position is within the borders
        if new_position in state['border']:
            continue
        
        # Check if the new position contains a pushable object
        can_move = True
        for pushable in state['pushables']:
            if new_position in state[pushable]:
                # Try to push the pushable object
                if not push_pushable(state, new_state, pushable, new_position, direction):
                    can_move = False
                    break
        
        # If the move is valid, update the position of the controllable
        if can_move:
            new_state[controllable][0] = new_position
    
    return new_state

def push_pushable(state, new_state, pushable, position, direction):
    # Calculate the new position of the pushable object
    next_position = [position[0] + direction[0], position[1] + direction[1]]
    
    # Check if next position is within the borders
    if next_position in state['border']:
        return False
    
    # Check if the next position has another pushable object
    for other_pushable in state['pushables']:
        if next_position in state[other_pushable]:
            # Recursively try to push the next pushable
            if not push_pushable(state, new_state, other_pushable, next_position, direction):
                return False
    
    # If the next position is valid, move the pushable
    for pushable in state['pushables']:
        if position in state[pushable]:
            new_state[pushable].remove(position)
            new_state[pushable].append(next_position)
    
    return True
```

### Explanation:

1. **Deep Copy**: We create a deepcopy of the state to ensure modifications do not affect the original state unless necessary.

2. **Action Handling**: We determine the direction vector from the `action` and attempt to move each controllable object in that direction.

3. **Collision Checking**: Before moving, we check if the new position is within the borders and if it contains any pushable objects.

4. **Pushing Logic**: If a pushable object is encountered, we attempt to push it recursively. If the push is blocked (e.g., by a border or another pushable that cannot be moved), the movement is invalid.

5. **State Update**: If the movement is valid, we update the positions of the controllable and pushable objects in the new state.

This model handles movement and recursive pushing, ensuring that objects are moved according to the rules specified while respecting game boundaries.