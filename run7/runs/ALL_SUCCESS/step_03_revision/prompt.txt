 You are an AI agent that must come up with a model of the game you are playing. This model you are making of the game
will be a python program that captures the logic and mechanics of the game. You have begun this world model, but it did not capture everything. Below is your current world model, the action space, and the state transition that your transition model handled wrong.

In order to craft the world model and get this state transition you explored your environment with an EXPLORATION PLAN, The state initially and after executing this plan is shown below. Pay close attention to what is involved and modify your transition model to be able to handle this.

Note this exploration is a high level plan and the transition returned is at the end of executing all the actions(right, left, up, down) related to this high level plan.

Notes:

Also DO NOT make changes to "won" in the state dictionary since that will happen outside of the world model.

Feel free to also explain your thinking outside of the markup tags, but know that I will only use the code inside the markup tags. 

Your response format is given below. You will never need to modify any of the current program loops. Your code should only be an addition outside of the current logic just as shown in the example.

You can access the current rules_formed by state['rules_formed'], pushables by state['pushables'], etc.. You DO NOT need to handle their modification, the game engine returns them updated.  

However, based on the rules_formed you may need to adjust the entities or other dictionary elements.
 

ACTION SPACE:

['up', 'down', 'left', 'right']

STATE FORMAT: 

\{
    <object 1>: [(x, y)],  # some object class and its location
    <object 2>: [(x, y), ...],  # some other object class and its locations
    ...  # etc.
    'lost': <bool>,  # Whether game has been lost yet
    'won': <bool>,  # Whether game has been won yet
\}

CURRENT WORLD MODEL:

# make sure to include these import statements
from copy import deepcopy
from utils import directions

def manage_rule_changes(state):
    # Check if 'rock_word is_word flag_word' rule is formed
    if 'rock_word is_word flag_word' in state['rules_formed']:
        # Convert rock_obj to flag_obj and manage overlappables
        if 'flag_obj' not in state:
            state['flag_obj'] = []
        state['flag_obj'].extend(state.get('rock_obj', []))
        state.pop('rock_obj', None)
        
        # Mark flag_obj as overlappable
        state['overlappables'].append('flag_obj')

def transition_model(state, action):
    # Create a deepcopy of the state to avoid modifying the original state directly
    new_state = deepcopy(state)
    
    # Get the action direction vector
    direction = directions[action]
    
    # Iterate over all controllable objects and attempt to move them
    for controllable in state['controllables']:
        # Get the current position of the controllable object
        current_position = state[controllable][0]
        
        # Calculate the new position after the action
        new_position = [current_position[0] + direction[0], current_position[1] + direction[1]]
        
        # Check if the new position is within the borders
        if new_position in state['border']:
            continue
        
        # Check if the new position contains a pushable object
        can_move = True
        for pushable in state['pushables']:
            if new_position in state[pushable]:
                # Try to push the pushable object
                if not push_pushable(state, new_state, pushable, new_position, direction):
                    can_move = False
                    break
        
        # If the move is valid, update the position of the controllable
        if can_move:
            new_state[controllable][0] = new_position
    
    # Manage rule changes after movements
    manage_rule_changes(new_state)
    
    return new_state

def push_pushable(state, new_state, pushable, position, direction):
    # Calculate the new position of the pushable object
    next_position = [position[0] + direction[0], position[1] + direction[1]]
    
    # Check if next position is within the borders
    if next_position in state['border']:
        return False
    
    # Check if the next position has another pushable object
    for other_pushable in state['pushables']:
        if next_position in state[other_pushable]:
            # Recursively try to push the next pushable
            if not push_pushable(state, new_state, other_pushable, next_position, direction):
                return False
    
    # If the next position is valid, move the pushable
    for pushable in state['pushables']:
        if position in state[pushable]:
            new_state[pushable].remove(position)
            new_state[pushable].append(next_position)
    
    return True


ERRORS FROM WORLD MODEL:

Initial state: {'border': [[0, 9], [0, 8], [0, 7], [0, 6], [0, 5], [0, 4], [0, 3], [0, 2], [0, 1], [0, 0], [1, 9], [1, 0], [2, 9], [2, 0], [3, 9], [3, 0], [4, 9], [4, 0], [5, 9], [5, 0], [6, 9], [6, 0], [7, 9], [7, 0], [8, 9], [8, 0], [9, 9], [9, 8], [9, 7], [9, 6], [9, 5], [9, 4], [9, 3], [9, 2], [9, 1], [9, 0]], 'baba_word': [[1, 8]], 'flag_word': [[1, 7]], 'goop_obj': [[1, 6], [1, 5], [1, 4], [1, 3], [1, 2], [1, 1], [2, 1], [3, 6], [3, 5], [3, 4], [3, 3], [3, 1], [4, 8], [4, 7], [4, 6], [4, 5], [4, 4], [4, 3], [4, 1], [5, 8], [5, 7], [5, 6], [5, 5], [5, 4], [6, 5], [6, 4], [7, 5], [7, 4], [8, 5], [8, 4]], 'is_word': [[2, 8], [2, 7], [7, 2]], 'baba_obj': [[2, 6]], 'you_word': [[3, 8]], 'win_word': [[3, 7]], 'goop_word': [[6, 2]], 'flag_obj': [[7, 7]], 'sink_word': [[8, 2]], 'lost': False, 'controllables': ['baba_obj'], 'overlappables': ['flag_obj'], 'pushables': ['is_word', 'goop_word', 'flag_word', 'baba_word', 'sink_word', 'win_word', 'you_word'], 'rules_formed': ['baba_word is_word you_word', 'flag_word is_word win_word', 'goop_word is_word sink_word']}
Action: right
Next state: {'border': [[0, 9], [0, 8], [0, 7], [0, 6], [0, 5], [0, 4], [0, 3], [0, 2], [0, 1], [0, 0], [1, 9], [1, 0], [2, 9], [2, 0], [3, 9], [3, 0], [4, 9], [4, 0], [5, 9], [5, 0], [6, 9], [6, 0], [7, 9], [7, 0], [8, 9], [8, 0], [9, 9], [9, 8], [9, 7], [9, 6], [9, 5], [9, 4], [9, 3], [9, 2], [9, 1], [9, 0]], 'baba_word': [[1, 8]], 'flag_word': [[1, 7]], 'goop_obj': [[1, 6], [1, 5], [1, 4], [1, 3], [1, 2], [1, 1], [2, 1], [3, 5], [3, 4], [3, 3], [3, 1], [4, 8], [4, 7], [4, 6], [4, 5], [4, 4], [4, 3], [4, 1], [5, 8], [5, 7], [5, 6], [5, 5], [5, 4], [6, 5], [6, 4], [7, 5], [7, 4], [8, 5], [8, 4]], 'is_word': [[2, 8], [2, 7], [7, 2]], 'you_word': [[3, 8]], 'win_word': [[3, 7]], 'goop_word': [[6, 2]], 'flag_obj': [[7, 7]], 'sink_word': [[8, 2]], 'won': False, 'lost': True, 'controllables': [], 'overlappables': ['flag_obj'], 'pushables': ['is_word', 'goop_word', 'flag_word', 'baba_word', 'sink_word', 'win_word', 'you_word'], 'rules_formed': ['baba_word is_word you_word', 'flag_word is_word win_word', 'goop_word is_word sink_word']}

Your prediction errors:
"baba_obj": predicted: [[3, 6]]
"baba_obj": actual: []

"lost": predicted: False
"lost": actual: True

"goop_obj": extraneous: [[3, 6]]

"controllables": predicted: ['baba_obj']
"controllables": actual: []


UTILS:

directions = {
        'left': [-1, 0],
        'right': [1, 0],
        'up': [0, 1],
        'down': [0, -1],
    }



RESPONSE FORMAT (make sure to include your code in markup tags):

```Python

# make sure to include these import statements
from predicates import *
from copy import deepcopy
from utils import directions

def transition_model(state, action):

       if 'x_word y_word z_word' in state['rules_formed']:
              state[x_obj] # example logic
        else:
              state[y_obj] # example logic
	


        Return State

```
